{
  "hash": "76f35b1fa4c4a71fcdf20fe50af3d9a3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Structural Causal Models\nsubtitle: introduction\nauthor: Wouter van Amsterdam\ndate: 2024-08-06\nformat: \n    #latex:\n        #documentclass: beamer\n        #lof: true\n        #lot: true\n    #html:\n        #toc: true\n        #toc-depth: 2\n        #number-sections: true\n    revealjs:\n        theme: umcu.scss\n        incremental: true\n        width: 1600\n        height: 900\n        logo: umcu_blue.png\n        center: true\nexecute:\n    warning: false\n    message: false\ncategories:\n    - SCM\n    - DAG\n    - day2\nbibliography: bibliography.bib\n---\n\n\n::: {.cell execute='true'}\n\n:::\n\n\n\n<!--\n\nQs:\n\n1. what knowledge of probability to expect? e.g. conditioning\n\n--->\n\n# DAG-recap\n\n## In past lectures on DAGs\n\n1. causal directed acyclic graphs (DAGs) encode assumptions on what variables cause what\n2. an intervention is defined as a mutilation of this DAG where the treatment variable no longer 'listens' to its parents\n3. a causal effect is the effect of an intervention\n4. DAG patterns:\n    - fork (confounding)\n    - chain (mediation)\n    - collider\n\n5. typically: \n  - condition on confounders, don't condition on mediators or colliders\n\n6. in more complex DAGs, use d-separation to check identifyability\n7. backdoor criterion\n\n## In this lecture: structural causal models (SCMs)\n\n::: {layout-ncol=2}\n\n\\begin{align}\n  U_Z, U_T, U_Y &\\sim p(U) \\\\\n  Z &= f_Z(U_Z) \\\\\n  T &= f_T(Z,U_T) \\\\\n  Y &= f_Y(T,Z,U_Y)\n\\end{align}\n\n![](figs/scmart.png)\n\n:::\n\n## Why SCMs?\n\n- With DAGs we can:\n    - express (non-parametric) prior knowledge\n    - understand that seeing $\\neq$ doing\n    - know what variables to condition on for estimating treatment effect\n- However,\n    - DAGs and RCTs do not cover all causal questions\n    - SCMs go a level deeper than DAGs\n    - DAGs naturally 'arise' from SCMs\n    - some questions are not identified when only specifying a DAG, but we may have additional information that can lead to identification\n    - understand 'identifyability'\n    - SCM thinking aligns [^according to me] with physical thinking about the world and is a natural way to think about causality\n\n---\n\n![](figs/inception_go_deeper.jpg)\n\n## Topics of today\n\n- SCMs: the world as computer programs\n- interventions are submodels\n- bonus queries:\n    - counterfactuals\n- Pearl Causal Hierarchy\n<!-- - other uses of DAGs: missing data, selection -->\n- reflections on DAGs, limitations\n\n# Structural Causal Models: definitions\n\n## Think of the world as a computer program with a set of \n\n- (endogenous) *variables*:\n  - `surgery` = duration of surgery (hours)\n  - `los` = length of stay in hospital post surgery (days)\n  - `survival` = survival time (years)\n- *background variables* (exogenous):\n  - `u_surgery`, `u_los`, `u_survival`\n- *functions* `f_` for each *variable* which depend on its *parents* `pa_` and its own *background* `u_`:\n  - `surgery = f_surgery(pa_surgery,u_surgery)`\n  - `los = f_los(pa_los, u_los)`\n  - `survival = f_survival(pa_survival, u_survival)`\n  \n:::{.fragment}\n\n<!-- The variables $\\mathbb{V}$, background $\\mathbb{U}$ and functions $\\mathbb{F}$  -->\nTogether these define a *Structural Causal Model* [see definition 7.1.1 in @pearlLogicStructureBasedCounterfactuals2009, and further] (notation: $M=<U,V,F>$)\n\n:::\n\n## Structural Causal Model 1{#sec-scm1}\n\n\n::: {.cell execute='false' output-location='fragment'}\n\n```{.r .cell-code  code-line-numbers=\"1-3|4-6|7-9|11-16|18\"}\nf_surgery <- function(u_surgery) { # pa_surgery = {}\n  u_surgery\n}\nf_los <- function(surgery, u_los) { # pa_los = {surgery}\n  surgery + u_los\n}\nf_survival <- function(surgery, los, u_survival) { # pa_survival = {sugery, los}\n  survival = los - 2 * surgery + u_survival\n}\n\nscm1 <- function(u_surgery, u_los, u_survival) {\n  surgery  = f_surgery(u_surgery)\n  los      = f_los(surgery, u_los)\n  survival = f_survival(surgery, los, u_survival)\n  c(surgery=surgery, los=los, survival=survival)\n}\nscm1(2, 1, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n surgery      los survival \n       2        3        4 \n```\n\n\n:::\n:::\n\n\n## Recursive Structural Causal Models imply a Directed Acyclic Graph\n\nAn SCM is *recursive*, i.e. *acyclic* when following the chain of parents, you never end up at the same variable twice\n\n:::{.columns}\n::::{.column width=\"50%\"}\n\n::: {.cell execute='false'}\n\n```{.r .cell-code  code-line-numbers=\"|2\"}\nscm1 <- function(u_surgery, u_los, u_survival) {\n  surgery  = f_surgery(u_surgery)\n  los      = f_los(surgery, u_los)\n  survival = f_survival(surgery, los, u_survival)\n  c(surgery=surgery, los=los, survival=survival)\n}\n```\n:::\n\n::::\n::::{.column width=\"50%\"}\n![](figs/scm1_01.png){.fragment}\n::::\n:::\n\n## Recursive Structural Causal Models imply a Directed Acyclic Graph\n\nAn SCM is *recursive*, i.e. *acyclic* when following the chain of parents, you never end up at the same variable twice\n\n:::{.columns}\n::::{.column width=\"50%\"}\n\n::: {.cell execute='false'}\n\n```{.r .cell-code  code-line-numbers=\"3\"}\nscm1 <- function(u_surgery, u_los, u_survival) {\n  surgery  = f_surgery(u_surgery)\n  los      = f_los(surgery, u_los)\n  survival = f_survival(surgery, los, u_survival)\n  c(surgery=surgery, los=los, survival=survival)\n}\n```\n:::\n\n::::\n::::{.column width=\"50%\"}\n![](figs/scm1_02.png)\n::::\n:::\n\n## Recursive Structural Causal Models imply a Directed Acyclic Graph\n\nAn SCM is *recursive*, i.e. *acyclic* when following the chain of parents, you never end up at the same variable twice\n\n:::{.columns}\n::::{.column width=\"50%\"}\n\n::: {.cell execute='false'}\n\n```{.r .cell-code  code-line-numbers=\"4\"}\nscm1 <- function(u_surgery, u_los, u_survival) {\n  surgery  = f_surgery(u_surgery)\n  los      = f_los(surgery, u_los)\n  survival = f_survival(surgery, los, u_survival)\n  c(surgery=surgery, los=los, survival=survival)\n}\n```\n:::\n\n::::\n::::{.column width=\"50%\"}\n![](figs/scm1_03.png)\n::::\n:::\n\n. . .\n\n`scm1` (without specifying the `f_`s) and the DAG are equivalent (they describe the same knowledge of the world)\n\nfor the remainder, we assume recursiveness\n\n\n## Submodel and Effect of Action\n\n- **submodel**: in `scm1` replace `f_los` with a specific *value*, e.g. `7` days\n<!-- todo: make this side-by-side -->\n\n\n::: {.cell execute='false' output-location='fragment'}\n\n```{.r .cell-code  code-line-numbers=\"1|3|8\"}\nsubmodel7 <- function(u_surgery, u_los, u_survival) {\n  surgery = f_surgery(u_surgery)\n  los = 7\n  survival = f_survival(surgery, los, u_survival)\n  c(surgery=surgery, los=los, survival=survival)\n}\n\nsubmodel7(2, 1, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n surgery      los survival \n       2        7        8 \n```\n\n\n:::\n:::\n\n\n- **effect of action**: resulting SCM of submodel (notation: $M_x=<U,V,F_x>$)\n\n\n## Submodel and Effect of Action as a mutilated DAG\n\nIn `scm1` replace `f_los` with a specific *value*, e.g. `7` days (notation: $M_x$)\n\n:::{.columns}\n::::{.column width=\"50%\"}\n\n::: {.cell execute='false'}\n\n```{.r .cell-code}\nsubmodel7 <- function(u_surgery, u_los, u_survival) {\n  surgery = f_surgery(u_surgery)\n  los = 7\n  survival = f_survival(surgery, los, u_survival)\n  c(surgery=surgery, los=los, survival=survival)\n}\n\nsubmodel7(2, 1, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n surgery      los survival \n       2        7        8 \n```\n\n\n:::\n:::\n\n\n::::\n::::{.column width=\"50%\"}\n::::: {.r-stack}\n\n![](figs/scm1_03.png){.fragment}\n\n![](figs/scm1_04.png){.fragment}\n\n:::::\n::::\n:::\n\n. . .\n\nThe DAG describes a submodel where $T$ no longer 'listens' to any variables but is controlled to be equal to a specific value (e.g. 7)\n\nThe *Effect of Action* $do(X=x)$ is defined as the submodel $M_x$.\n\n\n## Specifying a distribution for exogenous variables U \n\n- Exogenous variables `U` represent random variation in the world.\n- We can specify a *distribution* for them (e.g. Gaussian, Uniform)\n\n. . .\n\n\n::: {.cell execute='false' output-location='fragment'}\n\n```{.r .cell-code  code-line-numbers=\"1|2|3|4|7\"}\nsample_u <- function() {\n    u_surgery  = runif(1,  2,  8)\n    u_los      = runif(1, -1,  7)\n    u_survival = runif(1,  8, 13)\n    c(u_surgery=u_surgery, u_los=u_los, u_survival=u_survival)\n}\nsample_u()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n u_surgery      u_los u_survival \n 6.6997106  0.7016542  8.9951928 \n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell layout-align=\"center\" execute='true'}\n::: {.cell-output-display}\n![1000 random samples of U](lec3-scms_files/figure-revealjs/fig-u_samples-1.png){#fig-u_samples fig-align='center' width=960}\n:::\n:::\n\n\n## A Probabilistic Causal Model is a SCM with a distribution over U\n\n\n::: {.cell execute='true' output-location='fragment'}\n\n```{.r .cell-code  code-line-numbers=\"1|2|3|7\"}\nsample_pcm <- function() {\n  U <- sample_u()\n  V <- scm1(U[['u_surgery']], U[['u_los']], U[['u_survival']])\n  c(U, V)\n}\n  \nsample_pcm()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  u_surgery       u_los  u_survival     surgery         los    survival \n 2.01984790  0.09820628 12.33286294  2.01984790  2.11805418 10.41122132 \n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Realisations of endogenous variables V over random samples of U in [@fig-u_samples]](lec3-scms_files/figure-revealjs/fig-pcm1-samples-1.png){#fig-pcm1-samples width=960}\n:::\n:::\n\n\n## Calculating a treatment effect in a fully specified probabilistic causal model\n\n- take random samples from `U`, push forward through `submodel7` and `submodel3`\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code  code-line-numbers=\"1-2|4-5|7-18\"}\n# N = 1e3\n# us <- map(1:N, ~sample_u())\n\nv3s <- map(us, ~do.call(submodel3, as.list(.x)))\nv7s <- map(us, ~do.call(submodel7, as.list(.x)))\n\nv3df <- v3s |> map(~data.table(t(.x))) |> rbindlist()\nv7df <- v7s |> map(~data.table(t(.x))) |> rbindlist()\nv3df[, idx:=.I]\nv7df[, idx:=.I]\n\ndfa <- rbindlist(list(\n  scm1=vdf,\n  submodel3=v3df,\n  submodel7=v7df\n), idcol='model')\n\ndfa[, list(mean_survival=mean(survival)), by=\"model\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       model mean_survival\n      <char>         <num>\n1:      scm1      8.485179\n2: submodel3      3.571035\n3: submodel7      7.571035\n```\n\n\n:::\n:::\n\n\n# Identification\n\n## Recap of definitions\n\n- *Structural Causal model*:\n  - endogenous variables $V$\n  - exogenous (noise) variables $U$\n  - deterministic functions `f_i(pa_i,u_i)`\n- *Effect of Action* do$(T=t)$: *submodel* where `f_T` replaced with fixed value `t`\n- *Probabilistic Causal Model*: SCM + distribution over U\n\n## In the real world\n\n- knowing the SCM is a super-power: you basically know everything revelant about the system, but in the real world:\n- we do not observe $U$\n- we typically do not know `f_`\n  - we may be willing to place *assumptions* on `f_` (e.g. generalized linear models)\n- we are presented with realizations $V_i$ of this SCM over a random sample of U\n  - this is another assumption on the *sampling* but this is largely orthogonal to causal inference\n- we may be interest in knowing:\n  1. what is the expected survival time if we *always* admit patients for exactly 7 days?\n\n. . .\n\nWhen and how might we learn the answer to such questions?\n\n## Identification {#sec-identification}\n\nCausal effect identification:\n\n## Definition 3.2.3 (Identifiability)\n\nLet $Q(M)$ be any computable quantity of a model $M$.\n\n. . .\n\nWe say that $Q$ is **identifiable** in a class $\\mathbb{M}$ of models if, for any pairs of models $M_1$ and $M_2$ from $\\mathbb{M}$,\n\n. . . \n\n$Q(M_1) = Q(M_2)$ whenever $P_{M_1} (y) = P_{M_2} (y)$.\n\n. . .\n\nIf our observations are limited and permit only a partial set $F_M$ of features (of $P_M(y)$) to be estimated,\n\n. . .\n\nwe define $Q$ to be identifiable from $F_M$ if $Q(M_1) = Q(M_2)$ whenever $F_{M_1} = F_{M_2}$.\n\n## Idenfitication in pictures\n\n<!--Someone killed the priest {{< iconify ph:knife >}} , we want to know who-dunnit ($=Q$)-->\nSomeone killed the priest (†), we want to know who-dunnit ($=Q$)\n\n. . . \n\nBased on prior knowledge we have *5 suspects* (all the SCMs compatible with our DAG)\n\n. . .\n\n![](figs/whodunnit-col.png)\n\n. . .\n\nIf we had full data, we would know it was $M_3$\n\n\n## Idenfitication in pictures\n\nSomeone killed the priest (†) , we want to know who-dunnit ($=Q$)\n\nBased on prior knowledge on *5 suspects* (all the SCMs compatible with our DAG)\n\n![](figs/whodunnit-gray.png)\n\nIf we had full data, we would have know it was $M_3$\n\nUnfortunately, it was dark an we only got a gray-scale image of the perpetrator\n\n. . .\n\nAll our suspects (models) lead to the same partial observations\n\n. . . \n\nBased on *observed data* and *assumptions* we cannot *identify* the answer to our question $Q$,\n\n. . .\n\ni.e. multiple models with different answers for $Q$ fit the observed data equally well\n\n## Not identified vs estimand\n\n![](figs/scm1_03.png){fig-align=\"center\"}\n\nThe backdoor adjustment in this DAG means the correct estimand is:\n\n\\begin{align}\n  P(Y|\\text{do}(T)) &= \\sum_{z} P(Y|T,z)P(Z=z)\n\\end{align}\n\n- If we did not observe $Z$, we could still come up with a latent-variable model for $Z$ and a model for $Y|T,Z$ and get a value.\n- However, we can formulate multiple distinct latent variable models that each yield a different treatment effect (i.e. the output of the estimand)\n- But these latent variable models all fit the *observed* data equally well\n- So we cannot identify the treatment effect\n\n## Seeing is not doing\n\n::: {layout-ncol=2}\n\n:::: {#fig-seeing}\n\n![](figs/scm1_03.png){height=250}\n\n\\begin{align}\n  P(Y|T) &= \\sum_{z} P(Y|T,z)P(Z=z|T)\n\\end{align}\n\n::::\n\n:::: {#fig-doing}\n\n![](figs/scm1_04.png){height=250}\n\n\\begin{align}\n  P(Y|T) &= \\sum_{z} P(Y|T,z)P(Z=z|T) \\\\\n         &=^2 \\sum_{z} P(Y|T,z)P(Z=z)\n\\end{align}\n\n$^2$ because in the intervened DAG, $Z$ is independent of $T$\n\n::::\n\n:::\n\n. . .\n\n- $P(Y|\\text{do}(T)) \\neq P(Y|T)$ is Pearl's definition of confounding (def 6.2.1)\n- this shows why RCTs are special (i.e. no backdoor paths into $T$)\n\n<!-- ## Definition 3.2.4 (Causal Effect Identifiability)\n\nThe causal effect of $X$ on $Y$ is identifiable from a graph $G$ if the quantity $P(y | \\hat{x})$ can be computed uniquely from any positive probability of the observed variables – that is, if $P_{M_1}(y|\\hat{x}) = P_{M_2}(y|\\hat{x})$ for every pair of models $M_1$ and $M_2$ with $P_{M_1}(v) = P_{M_2}(v) > 0$ and $G(M_1) = G(M_2) = G$. -->\n\n## Another path to identification: parametric assumptions\n\n- for example:\n    - assumption 1: $\\mathbb{M}_1$, all SCMs with same DAG\n    - assumption 2: $\\mathbb{M}_2$ SCMs with linear functions and Gaussian error terms\n    - assumption 1+2: $\\mathbb{M} = \\mathbb{M_1} \\cap \\mathbb{M_2}$ (DAG + linear gaussian)\n- many more effects are identified in this setting\n- 'works' with unobserved confounding, positivity violations\n- caveats:\n    - much harder to determine identifyability (no analogue of backdoor-rule)\n    - prefer weaker assumptions over stronger assumption\n\n\n# Defining counterfactuals and the causal hierarchy (of questions)\n\n## Counterfactuals\n\n- all of the above can be achieved with DAGs, but we haven't used SCMs *unique power* yet: counterfactuals\n- RCT / DAG questions: *What is the expected survival if we keep all patients in the hospital for 7 days?*\n\n\n## Take it one level higher: counterfactuals\n\n::: {layout-ncol=\"2\"}\n\n:::: {.column}\nFor patient Adam we had this data:\n\n- surgery duration: 4 hours\n- length of stay: 3 days\n- survival: 4 years\n\n::::\n\n:::: {.column}\n\nFor patient Zoe we had this data:\n\n- surgery duration: 4 hours\n- length of stay: 3 days\n- survival: 7.5 years\n\n::::\n\n:::\n\n- we do not observe Adam's/Zoe's `U`\n- What would the expected survival have been had Adam/Zoe been kept in the hospital for 7 days?\n\n## Adam versus Zoe\n\n- Average causal effects in subgroup with `surgery=4`: \n  - 3-days LOS: 5.6\n  - 7-days LOS: 9.6\n\n:::{.fragment}\n\n::: {.cell}\n::: {.cell-output-display}\n![](lec3-scms_files/figure-revealjs/counterfactuals-1.png){width=960}\n:::\n:::\n\n:::\n\n- what do we expect for Adam and Zoe if they would have been kept in the hospital for 7 days?\n\n## Computing counterfactuals with SCMs\n\n- Given our information on the structural equation for `survival` ([@sec-scm1]):\n  $$\\text{survival} = \\text{los} - 2*\\text{surgery} + u_{\\text{survival}}$$\n- and observed values on Adam's and Zoe's `surgery` AND `survival` following `los=3`\n- we can compute their individual $u_{\\text{survival}}$:\n\n:::{.r-stack}\n\n::::{.fragment .fade-in-then-out}\n|patient|surgery|los|survival|\n|-------|-------|---|--------|\n| Adam  | 4     | 3 | 4      |\n| Zoe   | 4     | 3 | 7.5    |\n::::\n\n::::{.fragment .fade-in-then-out}\n|patient|surgery|los|survival|u_survival|\n|-------|-------|---|--------|----------|\n| Adam  | 4     | 3 | 4      | 9        |\n| Zoe   | 4     | 3 | 7.5    | 12.5     |\n::::\n\n::::{.fragment}\n|patient|surgery|los|survival|u_survival|survival7|\n|-------|-------|---|--------|----------|---------|\n| Adam  | 4     | 3 | 4      | 9        | 8       |\n| Zoe   | 4     | 3 | 7.5    | 12.5     | 11.5    |\n::::\n\n:::\n\n- **and (counterfactual) survival under 7 days LOS**\n\n## Computing counterfactuals\n\n- notation: $P(Y_{t'}  = y' | T=t,Y=y)$ where $Y_{t'}$ means \"set $T=t'$ through intervention\"\n- steps:\n  1. Abduction (update $P(U)$ from observed evidence)\n  2. Action (modify the treatment)\n  3. Prediction (calculate outcomes in submodel, putting in the updated $P(U)$)\n\n## Pearl's Causal Hierarchy (of questions)\n\nIf you have data to solve the upper, you can solve the lower ranks too [@bareinboimPearlHierarchyFoundations2022]\n\n1. counterfactuals\n2. interventions\n3. associations\n\n## Where do we get this knowledge from?\n\n- not from observational data\n- not from RCTs\n- from assumptions\n- can get bounds from combinations of RCT data and observational data\n- caveat: some say the hierarchy is upside down because you go further away from data and closer to unverifiable assumptions the 'higher' you get\n\n## Not covered but also possible:\n\n- DAGs:\n  - *soft intervention*: don't set treatment to fixed value but replace function with other function of variables\n  - express patterns for missing data by including missingness indicators\n- SCMs:\n  - probability of sufficiency\n  - probability of necessity\n\n## References\n\n",
    "supporting": [
      "lec3-scms_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}